### 指令跳转：原来if..else就是goto

**CPU是如何执行指令的？**

逻辑上，我们可以认为，CPU其实就是由一堆寄存器组成的。而寄存器就是CPU内部，由多个触发器或者锁存器组成的简单电路。触发器和锁存器，其实就是两种不同原理的数字电路组成的逻辑门。

<img src="/Users/jackie/Documents/GitHub/DM/image/CPU寄存器.jpg">

1.PC寄存器，我们也叫指令地址寄存器。用来存放下一条需要执行的计算机指令的内存地址。

2.指令寄存器，用来存放当前正在执行的指令。

3.条件码寄存器，用里面的一个一个标记位（Flag）,存放CPU进行算术或逻辑计算的结果，存储的是逻辑和条件运算的结果标记位。

 

程序执行的时候，CPU会根据PC寄存器里的地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。可以看到，一个程序的一条条指令，在内存里面是连续保存的，也会一条条顺序加载。但是有些特殊指令，比如跳转指令，会修改PC寄存器里面的地址值。这样我们下一条要执行的指令就不是从内存里面顺序加载的了，也是因为这些指令，我们可以使用if..else,while/for

如果执行的当前指令带有跳转的地址，比如往后跳10个指令，那么机器会自动将卡带往后移动10个指令的位置，再来执行指令，同样也可以向前移动，去读取之前已经执行过的指令。这就是while/for循环的实现原理。

虽然我们在高级语言开发程序的时候反对使用goto，但是实际在机器指令层面，无论是if..else，for/while，都是用和goto相同的跳转到指定指令的位置的方式来实现的。

总结：除了简单的通过PC寄存器自增的方式顺序执行外，条件码寄存器会记录下当前执行指令的条件判断状态，然后通过跳转指令读取相应的条件码，修改PC寄存器内的下一条指令的地址，最终实现if..else 已经for/while这样的程序控制流程。



这一讲的核心在于理解几个寄存器的作用，从而理解cpu运行程序的过程：cpu从PC寄存器中取地址，找到地址对应的内存位置，取出其中指令送入指令寄存器执行，然后指令自增，重复操作。所以只要程序在内存中是连续存储的，就会顺序执行这也是冯诺依曼体系的理念吧。而实际上跳转指令就是当前指令修改了当前PC寄存器中所保存的下一条指令的地址，从而实现了跳转。当然各个寄存器实际上是由数电中的一个一个门电路组合出来的，而各个门电路的具体电路形式也是属于模电的东西。对于我们来说，有个具体概念就行，实在需要的时候再回去翻翻课本捡起来就行。



Switch case  和if/else的使用情况

switch判断条件多，且最好case之间的差值不要过大的时候最好使用switch

switch case 要看编译器有没有生成跳表，没有的话跟if else效率应该是一样的，比如case个数比较少的情况









